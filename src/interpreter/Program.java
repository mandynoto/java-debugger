/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package interpreter;

import interpreter.bytecode.*;

import java.util.ArrayList;
import java.util.HashMap;

/**
 * Holds generated byte codes.
 *
 * @author mandynoto
 */
public class Program
{

	// A container for a list of byte codes.
	private final ArrayList<ByteCode> program;

	/**
	 * Constructs an empty program.
	 */
	public Program()
	{
		program = new ArrayList<>();
	}

	/**
	 * Returns the ByteCode of the specified program counter.
	 *
	 * @param pc the specified program counter.
	 * @return the ByteCode based on the specified program counter.
	 */
	public ByteCode getCode(int pc)
	{
		return this.program.get(pc);
	}

	/**
	 * Returns the size of this program.
	 *
	 * @return
	 */
	public int getSize()
	{
		return this.program.size();
	}

	/**
	 * Adds a byte code into this program's array list.
	 *
	 * @param byteCode
	 */
	public void add(ByteCode byteCode)
	{
		program.add(byteCode);
	}

	/**
	 * Resolves the address of the specified program. Basically, it discovers
	 * and returns the address of the specified program.
	 *
	 * @param program the specified program.
	 */
	public void resolveAddress(Program program)
	{
		// A mapping of an address and its associated program counter.
		HashMap<String, Integer> labelAddressToCount = new HashMap<>();

		// An address index for the byte codes: call, false branch, and go to.
		int addressPC = 1;

		// Add label codes into the labelAddressToCount hashmap.
		while (addressPC < program.getSize())
		{
			ByteCode Address = program.getCode(addressPC);
			if (Address instanceof LabelCode)
			{
				labelAddressToCount.put(((LabelCode) Address).getAddress(), addressPC);
			}
			addressPC += 1;

		}

		// Swap the address of the hash map values with ...
		// ... discovered CALL, GOTO, and FALSEBRANCH byte codes.
		addressPC = 0;
		while (addressPC < program.getSize())
		{
			ByteCode address = program.getCode(addressPC);
			if (address instanceof CallCode)
			{
				if (labelAddressToCount.containsKey(((CallCode) address).getFunctionNameAddress()))
				{
					((CallCode) address).setFunctionNameAddress(labelAddressToCount.get(((CallCode) address).getFunctionNameAddress()));
				}
			}
			if (address instanceof FalseBranchCode)
			{
				if (labelAddressToCount.containsKey(((FalseBranchCode) address).getLabelAddress()))
				{
					((FalseBranchCode) address).setLabelAddress(labelAddressToCount.get(((FalseBranchCode) address).getLabelAddress()));
				}
			}
			if (address instanceof GotoCode)
			{
				if (labelAddressToCount.containsKey(((GotoCode) address).getLabelAddress()))
				{
					((GotoCode) address).setLabelAddress(labelAddressToCount.get(((GotoCode) address).getLabelAddress()));
				}
			}
		
			addressPC += 1;
		}
	}

}
